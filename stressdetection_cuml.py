# -*- coding: utf-8 -*-
"""stressdetection_cuml.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Mf2M_Wga6oJO5-P2KFWz_ZZu0HpN3f3D
"""



# This get the RAPIDS-Colab install files and test check your GPU.  Run this and the next cell only.
# Please read the output of this cell.  If your Colab Instance is not RAPIDS compatible, it will warn you and give you remediation steps.
!git clone https://github.com/rapidsai/rapidsai-csp-utils.git
!python rapidsai-csp-utils/colab/pip-install.py

from google.colab import drive
drive.mount('/content/drive')

!pip install cuml

import cudf
import cupy as cp
import numpy as np
from cuml.ensemble import RandomForestClassifier
from cuml.model_selection import train_test_split
from cuml.metrics import accuracy_score, confusion_matrix, roc_auc_score
from cuml.preprocessing import LabelEncoder
from sklearn.model_selection import GridSearchCV

df = cudf.read_csv('/content/drive/MyDrive/stress_detection.csv')

X = df.drop(['participant_id', 'day'], axis=1)

X['PSS_score'] = cudf.to_numeric(X['PSS_score'], errors='coerce')

# Create a new column to store the stress categories
X['stress_category'] = ''

for row in range(0, len(X['PSS_score'])):
    if X['PSS_score'].iloc[row] < 20:
        X['stress_category'].iloc[row] = 'low_stress'
    elif X['PSS_score'].iloc[row] >= 20 and X['PSS_score'].iloc[row] < 30:
        X['stress_category'].iloc[row] = 'medium_stress'
    else:
        X['stress_category'].iloc[row] = 'high_stress'

X['stress_category'].head(20)

lb = LabelEncoder()
X['stress_category'] = lb.fit_transform(X['stress_category'])
X.head(20)

y= X['stress_category']
X = X.drop(['PSS_score','stress_category'],axis=1)

y.head(10)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.3, random_state = 919, stratify=y)

RF_Classifier = RandomForestClassifier()

param_grid_rf = {
    'n_estimators' : [100],
    'bootstrap' : [True],
    'max_features' : ["sqrt", "log2"],
    'max_depth': np.arange(2,30),
    #'min_samples_leaf': np.arange(2,40),
    #'max_leaf_nodes': np.arange(2, 20),
    }

grid_rf = GridSearchCV(estimator = RF_Classifier, param_grid=param_grid_rf, cv=5, n_jobs = -1)

grid_rf.fit(X_train.to_numpy(), y_train.to_numpy())

grid_rf.best_params_

grid_rf.score(X_test.to_numpy(), y_test.to_numpy() )

y_test = y_test.astype(np.int64)

# Get predictions and convert to int64
y_pred = grid_rf.predict(X_test.to_numpy()).astype(np.int64)

# Calculate confusion matrix
cm = confusion_matrix(y_test, y_pred)

print(cm)

auc = roc_auc_score(y_test, y_pred)
print(auc)

import xgboost as xgb

train = xgb.DMatrix(X_train, label=y_train)
test = xgb.DMatrix(X_test, label=y_test)

xgb_params = {
    'max_depth': 10,
    'learning_rate': 0.1,
    'objective': 'multi:softmax',
    'n_gpus': 1,
    'tree_method': 'hist',
    'device': 'cuda',
    'eval_metric': 'auc',
    'num_class': 3
}

model = xgb.train(params = xgb_params,dtrain=train, num_boost_round=100)

y_pred = model.predict(test)

y_pred = y_pred.astype(np.int64)

# Calculate confusion matrix
cm = confusion_matrix(y_test, y_pred)

print(cm)

auc = roc_auc_score(y_test, y_pred)
print(auc)

from cuml.neighbors import KNeighborsClassifier

model = KNeighborsClassifier()

model.fit(X_train.to_numpy(), y_train.to_numpy())

model.score(X_test.to_numpy(), y_test.to_numpy())

y_pred = model.predict(X_test)
y_test = y_test.astype(np.int64)

y_pred = y_pred.astype(np.int64)

# Calculate confusion matrix
cm = confusion_matrix(y_test, y_pred)

print(cm)

auc = roc_auc_score(y_test, y_pred)
print(auc)